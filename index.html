<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Velocidade com Acelerômetro e Média Móvel</title>
</head>
<body>
    <br>
    <h1 id="velocity">Velocidade: 0 m/s</h1>
    <br>
    <button id="startButton">Iniciar Captura de Movimento</button>

    <script>
        let velocity = 0;
        let lastTime = Date.now();
        const accValues = { x: [], y: [], z: [] };
        const N = 5; // Número de amostras para a média móvel
        const stationaryThreshold = 0.05; // Limite para considerar o dispositivo como parado
        let stationaryTime = 0;

        function addAccValue(axis, value) {
            accValues[axis].push(value);
            if (accValues[axis].length > N) {
                accValues[axis].shift(); // Remove o valor mais antigo
            }
        }

        function calculateAverage(axis) {
            return accValues[axis].reduce((sum, val) => sum + val, 0) / accValues[axis].length;
        }

        function updateVelocity(ax, ay, az) {
            let currentTime = Date.now();
            let deltaTime = (currentTime - lastTime) / 1000; // Tempo em segundos
            lastTime = currentTime;

            // Adiciona os valores atuais e calcula a média para cada eixo
            addAccValue('x', ax);
            addAccValue('y', ay);
            addAccValue('z', az);
            let avgAx = calculateAverage('x');
            let avgAy = calculateAverage('y');
            let avgAz = calculateAverage('z');

            // Verifica se o dispositivo está parado
            let accelerationMagnitude = Math.sqrt(avgAx * avgAx + avgAy * avgAy + avgAz * avgAz);
            if (accelerationMagnitude < stationaryThreshold) {
                stationaryTime += deltaTime;
            } else {
                stationaryTime = 0; // Resetar o contador de tempo parado se houver movimento
            }

            // Se o dispositivo estiver parado por mais de um certo tempo, zere a velocidade
            if (stationaryTime > 0.5) { // Considerar parado após meio segundo
                velocity = 0;
            } else {
                // Calcula a velocidade com base na aceleração média
                velocity += accelerationMagnitude * deltaTime;
            }

            document.getElementById('velocity').textContent = `Velocidade: ${velocity.toFixed(2)} m/s`;
        }

        function handleMotionEvent(event) {
            let ax = event.acceleration.x;
            let ay = event.acceleration.y;
            let az = event.acceleration.z;
            updateVelocity(ax, ay, az);
        }

        function initSensor() {
            if ('LinearAccelerationSensor' in window) {
                const sensor = new LinearAccelerationSensor();
                sensor.addEventListener('reading', () => updateVelocity(sensor.x, sensor.y, sensor.z));
                sensor.start();
            } else if ('DeviceMotionEvent' in window) {
                window.addEventListener('devicemotion', handleMotionEvent);
            } else {
                alert('Sensores de movimento não são suportados neste dispositivo.');
            }
        }

        document.getElementById('startButton').addEventListener('click', function() {
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                // Para iOS 13+
                DeviceMotionEvent.requestPermission().then(permissionState => {
                    if (permissionState === 'granted') {
                        initSensor();
                    } else {
                        alert('Permissão para acessar os sensores negada.');
                    }
                }).catch(console.error);
            } else {
                // Para outros navegadores
                initSensor();
            }
        });
    </script>
</body>
</html>
